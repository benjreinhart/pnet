// Generated by CoffeeScript 2.0.0-beta7
void function () {
  var getParamErrors, normalizeMethod, omit, parseResponseBody, pnet, pnetConfig, pnetDefaults, request, safeExtend, Setlist, SETLIST_METHODS, underscore, urlFor;
  Setlist = require('./pnet/setlist');
  omit = (underscore = require('underscore')).omit;
  request = require('request');
  SETLIST_METHODS = [
    'pnet.shows.setlists.get',
    'pnet.shows.setlists.latest',
    'pnet.shows.setlists.random',
    'pnet.shows.setlists.recent',
    'pnet.shows.setlists.tiph'
  ];
  safeExtend = function (param$) {
    var extend;
    extend = param$.extend;
    return function () {
      return extend.apply(null, [{}].concat([].slice.call(arguments)));
    };
  }(underscore);
  pnetConfig = safeExtend(require('../config').pnet);
  pnetDefaults = safeExtend(pnetConfig.api.defaults);
  pnet = module.exports = {};
  pnet.get = function (method, params, callback) {
    var cache$, error, url;
    if (null == params)
      params = {};
    method = normalizeMethod(method);
    if (error = null != (cache$ = getParamErrors(method, params)) ? cache$[0] : void 0) {
      error = new Error(error.param + ' ' + error.message);
      process.nextTick(callback.bind(null, error));
      return;
    }
    url = urlFor(method, params);
    request.get(url, function (err, response, body) {
      var e;
      if (null != err || !(200 <= +response.statusCode && +response.statusCode < 300)) {
        return callback(null != err ? err : new Error('Response returned status code ' + response.statusCode));
      } else {
        try {
          return callback(null, url, parseResponseBody(method, body));
        } catch (e$) {
          e = e$;
          return callback(e);
        }
      }
    });
  };
  pnet.apikey = function (key) {
    if (!arguments.length)
      return pnetDefaults.apikey;
    if (key === null || key === void 0) {
      return pnetDefaults = omit(pnetDefaults, 'apikey');
    } else {
      return pnetDefaults.apikey = key;
    }
  };
  normalizeMethod = function (method) {
    if (null == method)
      method = '';
    if (!/^pnet\./.test(method))
      method = 'pnet.' + method;
    return method;
  };
  urlFor = function (method, params) {
    if (null == params)
      params = {};
    params = safeExtend(pnetDefaults, params, { method: method });
    return pnetConfig.api.baseUrl + '?' + function (accum$) {
      var key, value;
      for (key in params) {
        if (!isOwn$(params, key))
          continue;
        value = params[key];
        accum$.push('' + key + '=' + value);
      }
      return accum$;
    }.call(this, []).join('&');
  };
  getParamErrors = function (method, params) {
    var errors;
    if (null == params)
      params = {};
    errors = [];
    if (!(null != pnetConfig.api.methods[method]))
      errors.push({
        param: 'method',
        message: 'must be a valid phish.net API method'
      });
    if (null != params.showdate && !/^\d{4}-\d{2}-\d{2}$/.test(params.showdate))
      errors.push({
        param: 'showdate',
        message: 'must be in the format YYYY-MM-DD'
      });
    return errors.length && errors || null;
  };
  parseResponseBody = function (method, body) {
    var parsed;
    parsed = JSON.parse(body);
    if (null != parsed.success && parsed.success === 0)
      throw new Error(null != parsed.reason ? parsed.reason : 'Request failed with success code 0');
    if (in$(method, SETLIST_METHODS))
      parsed = function (accum$) {
        var show;
        for (var i$ = 0, length$ = parsed.length; i$ < length$; ++i$) {
          show = parsed[i$];
          accum$.push(safeExtend(show, Setlist.parse(show.setlistdata)));
        }
        return accum$;
      }.call(this, []);
    return parsed;
  };
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
  function in$(member, list) {
    for (var i = 0, length = list.length; i < length; ++i)
      if (i in list && list[i] === member)
        return true;
    return false;
  }
}.call(this);
