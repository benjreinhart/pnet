// Generated by CoffeeScript 2.0.0-beta7
void function () {
  var extractSongsFromSet, groupBySetsAndEncore, isSong, isSup, parseFootnotes, parseLink, parseSegue, parseSup, Path, RE, URL;
  URL = require('url');
  Path = require('path');
  RE = {
    closingTags: /\s*(<\/\w+\s*>\s*)*$/gim,
    footnotes: /<p[^>]+pnetfootnotes[^>]+>/gi,
    href: /href\s*=\s*'|"([^'"]+)/,
    lineBreaks: /\s*<br\s*\/?>\s*/gi,
    link: /<a[^>]+>\s*([^<]+)\s*<\/a\s*>/,
    newlines: /\n/,
    nonWhitespace: /\S+/,
    pnetset: /pnetset/,
    pnetsete: /pnetsete/,
    pnetSection: /(<p[^>]+pnetset[^>]+>)/gi,
    segue: /<\/\w+\s*>\s*(-?>)/,
    setLabels: /\s*<span[^>]+pnetsetlabel[^>]+>[^<]*<\/span\s*>\s*/gi,
    spaces: /\s+/g,
    supTag: /<sup[^>]*>([^<]+)<\/sup\s*>/,
    tags: /(<\w+[^>]*>[^<]*<\/\w+>[^<]*)/gi
  };
  groupBySetsAndEncore = function (sections) {
    var currentContext, encore, i, section, sets;
    sets = [];
    encore = [];
    currentContext = null;
    for (var i$ = 0, length$ = sections.length; i$ < length$; ++i$) {
      section = sections[i$];
      i = i$;
      if (RE.pnetset.test(section)) {
        if (RE.pnetsete.test(section)) {
          currentContext = encore;
        } else {
          currentContext = sets;
          if (RE.pnetset.test(sections[i + 1]))
            currentContext.push('');
        }
      } else {
        currentContext.push(section);
      }
    }
    return [
      sets,
      encore
    ];
  };
  isSong = RegExp.prototype.test.bind(RE.link);
  isSup = RegExp.prototype.test.bind(RE.supTag);
  parseSegue = function (tag) {
    var cache$;
    return null != (cache$ = tag.match(RE.segue)) ? cache$[1] : void 0;
  };
  parseSup = function (sup) {
    return sup.match(RE.supTag)[1];
  };
  parseLink = function (link) {
    var href, segue, song, title, url;
    href = link.match(RE.href)[1];
    title = link.match(RE.link)[1];
    url = URL.parse(href);
    song = {
      id: Path.basename(url.pathname),
      title: title,
      url: href
    };
    if (null != (segue = parseSegue(link)))
      song.segue = segue;
    return song;
  };
  parseFootnotes = function (footnotes) {
    return footnotes.replace(RE.closingTags, '').split(RE.newlines);
  };
  extractSongsFromSet = function (set) {
    var lastSong, segue, songs, tag, tags;
    songs = [];
    if (!(null != (tags = set.match(RE.tags))))
      return songs;
    lastSong = null;
    for (var i$ = 0, length$ = tags.length; i$ < length$; ++i$) {
      tag = tags[i$];
      if (isSong(tag)) {
        lastSong = parseLink(tag);
        songs.push(lastSong);
      } else if (isSup(tag)) {
        if (null != (segue = parseSegue(tag)))
          lastSong.segue = segue;
        lastSong.notes = parseSup(tag);
      }
    }
    return songs;
  };
  exports.parse = function (html) {
    var cache$, cache$1, encores, footnotes, parsedEncores, parsedFootnotes, parsedSets, sections, sets;
    if (null == html)
      html = '';
    html = html.replace(RE.lineBreaks, '\n').replace(RE.setLabels, '');
    cache$ = html.split(RE.footnotes);
    html = cache$[0];
    footnotes = cache$[1];
    sections = html.split(RE.pnetSection).filter(function (elem) {
      return RE.nonWhitespace.test(elem);
    });
    if (sections.length === 0 || sections.length === 1)
      return {
        sets: [],
        encores: [],
        footnotes: []
      };
    cache$1 = groupBySetsAndEncore(sections);
    sets = cache$1[0];
    encores = cache$1[1];
    parsedSets = (null != sets ? sets.length : void 0) ? function (accum$) {
      var set;
      for (var i$ = 0, length$ = sets.length; i$ < length$; ++i$) {
        set = sets[i$];
        accum$.push(extractSongsFromSet(set));
      }
      return accum$;
    }.call(this, []) : [];
    parsedEncores = (null != encores ? encores.length : void 0) ? function (accum$) {
      var encore;
      for (var i$ = 0, length$ = encores.length; i$ < length$; ++i$) {
        encore = encores[i$];
        accum$.push(extractSongsFromSet(encore));
      }
      return accum$;
    }.call(this, []) : [];
    parsedFootnotes = null != footnotes ? parseFootnotes(footnotes) : [];
    return {
      sets: parsedSets,
      encores: parsedEncores,
      footnotes: parsedFootnotes
    };
  };
}.call(this);
